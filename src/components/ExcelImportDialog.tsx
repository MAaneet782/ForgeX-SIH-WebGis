import { useState, useMemo, useRef } from "react"; // Added useRef
import * as XLSX from "xlsx";
import { supabase } from "@/lib/supabaseClient";
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Loader2, UploadCloud, FileWarning, Download } from "lucide-react";
import { showError, showSuccess, showLoading, dismissToast, showInfo } from "@/utils/toast"; // Added showInfo
import { useQueryClient } from "@tanstack/react-query";
import type { Claim } from "@/data/mockClaims";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { useAuth } from "@/context/AuthContext"; // Import useAuth

interface ExcelImportDialogProps {
  isOpen: boolean;
  onOpenChange: (open: boolean) => void;
  claims: Claim[]; // Added to receive existing claims for ID validation
}

// Define a type for the processed row data
interface ProcessedRow {
  originalRow: any;
  parsedClaim: Omit<Claim, 'dbId'> | null; // Claim without dbId as it's generated by Supabase
  errors: string[];
}

// Helper to convert Excel serial date to JS Date
const excelSerialToDate = (serial: number) => {
  if (isNaN(serial) || serial < 25569 || serial > 50000) return null; // Basic validation for Excel date range
  const utc_days = Math.floor(serial - 25569);
  const utc_value = utc_days * 86400;
  const date_info = new Date(utc_value * 1000);
  return new Date(date_info.getFullYear(), date_info.getMonth(), date_info.getDate());
};

// Approximate bounding boxes for allowed states (simplified for India)
const INDIA_BOUNDS = {
  minLat: 6.0, maxLat: 37.0, minLon: 68.0, maxLon: 98.0,
};

const isWithinIndiaBounds = (lat: number, lon: number): boolean => {
  return lat >= INDIA_BOUNDS.minLat && lat <= INDIA_BOUNDS.maxLat &&
         lon >= INDIA_BOUNDS.minLon && lon <= INDIA_BOUNDS.maxLon;
};

// Helper to create a polygon around a center point with size based on area
const createPolygonFromCenter = (lat: number, lon: number, areaInAcres: number) => {
    // Ensure lat/lon are valid numbers, fallback to a central Indian point if not
    if (isNaN(lat) || isNaN(lon) || !isWithinIndiaBounds(lat, lon)) {
      lat = 22.5937; // Default latitude for India (within MP bounds)
      lon = 78.9629; // Default longitude for India (within MP bounds)
    }

    const areaSqMeters = areaInAcres * 4046.86; // 1 acre = 4046.86 sq meters
    const minSideLengthMeters = 50; // Minimum side length for visibility (e.g., 50m for a small plot)
    const calculatedSideLengthMeters = Math.sqrt(areaSqMeters);
    const sideLengthMeters = Math.max(minSideLengthMeters, calculatedSideLengthMeters);

    // Approximate conversion factors for degrees to meters
    const metersPerDegreeLat = 111139; // At equator
    const metersPerDegreeLon = 111320 * Math.cos(lat * Math.PI / 180); // Varies by latitude

    const deltaLatDegrees = (sideLengthMeters / 2) / metersPerDegreeLat;
    const deltaLonDegrees = (sideLengthMeters / 2) / metersPerDegreeLon;

    // Create a simple square-like polygon
    const coords = [
        [lon - deltaLonDegrees, lat - deltaLatDegrees],
        [lon + deltaLonDegrees, lat - deltaLatDegrees],
        [lon + deltaLonDegrees, lat + deltaLatDegrees],
        [lon - deltaLonDegrees, lat + deltaLatDegrees],
        [lon - deltaLonDegrees, lat - deltaLatDegrees], // Close the polygon
    ];
    return { type: "Polygon", coordinates: [coords] };
};

// Helper to get value from potential column names (case-insensitive and space-tolerant)
const getCellValue = (row: any, keys: string[]) => {
  const normalizedRow: Record<string, any> = {};
  for (const key in row) {
    if (Object.prototype.hasOwnProperty.call(row, key)) {
      normalizedRow[key.toLowerCase().replace(/[^a-z0-9]/g, '')] = row[key];
    }
  }

  for (const key of keys) {
    const normalizedKey = key.toLowerCase().replace(/[^a-z0-9]/g, '');
    if (normalizedRow[normalizedKey] !== undefined && normalizedRow[normalizedKey] !== null) {
      return normalizedRow[normalizedKey];
    }
  }
  return undefined;
};

const ExcelImportDialog = ({ isOpen, onOpenChange, claims }: ExcelImportDialogProps) => {
  const queryClient = useQueryClient();
  const { user } = useAuth(); // Get the current user
  const [file, setFile] = useState<File | null>(null);
  const [processedData, setProcessedData] = useState<ProcessedRow[]>([]);
  const [isLoading, setIsLoading] = useState(false);

  const existingClaimUserFacingIds = useMemo(() => new Set(claims.map(c => c.id)), [claims]);
  const generatedUserFacingIdsInBatch = useRef<Set<string>>(new Set());

  const generateUniqueUserFacingClaimId = (baseId?: string): string => {
    let newId = baseId || `C-${Math.random().toString(36).substring(2, 9).toUpperCase()}`;
    let counter = 0;
    while (existingClaimUserFacingIds.has(newId) || generatedUserFacingIdsInBatch.current.has(newId)) {
      counter++;
      newId = `C-${Math.random().toString(36).substring(2, 9).toUpperCase()}`;
      if (counter > 100) {
          console.warn("Too many ID collisions, falling back to a more robust random ID.");
          newId = `C-${crypto.randomUUID().substring(0, 8).toUpperCase()}`;
          break;
      }
    }
    generatedUserFacingIdsInBatch.current.add(newId);
    return newId;
  };

  const processExcelRow = (row: any): ProcessedRow => {
    const errors: string[] = [];
    let parsedClaim: Omit<Claim, 'dbId'> | null = null;

    const holderName = String(getCellValue(row, ['patta holder', 'Patta Holder', 'holder name', 'Holder Name']) || '').trim();
    if (!holderName) errors.push("Holder Name is missing.");

    const village = String(getCellValue(row, ['village', 'Village']) || '').trim();
    if (!village) errors.push("Village is missing.");

    const district = String(getCellValue(row, ['district', 'District']) || 'Unknown').trim();
    const state = String(getCellValue(row, ['state', 'State']) || '').trim();
    if (!state) errors.push("State is missing.");

    const areaInHectaresRaw = getCellValue(row, ['area (ha)', 'Area (ha)', 'area', 'Area']);
    let areaInAcres = 0;
    if (typeof areaInHectaresRaw === 'number' && !isNaN(areaInHectaresRaw)) {
      areaInAcres = areaInHectaresRaw * 2.47105;
    } else {
      errors.push("Area (ha) is missing or invalid.");
    }
    if (areaInAcres <= 0) {
      errors.push("Area must be a positive number.");
    }

    const statusMap: { [key: string]: 'Approved' | 'Pending' | 'Rejected' } = {
      'IFR': 'Approved', 'CR': 'Pending', 'CFR': 'Rejected',
      'Approved': 'Approved', 'Pending': 'Pending', 'Rejected': 'Rejected',
    };
    const statusRaw = String(getCellValue(row, ['type of right', 'Type of Right', 'status', 'Status']) || '').trim();
    const status: 'Approved' | 'Pending' | 'Rejected' = statusMap[statusRaw] || 'Pending';

    const soilTypes: Claim['soilType'][] = ['Alluvial', 'Clay', 'Loamy', 'Laterite', 'Unknown'];
    const soilTypeRaw = String(getCellValue(row, ['soil type', 'Soil Type', 'soil']) || '').trim();
    const soilType: Claim['soilType'] = soilTypes.includes(soilTypeRaw as Claim['soilType']) ? (soilTypeRaw as Claim['soilType']) : 'Unknown';
    if (soilType === 'Unknown' && soilTypeRaw) errors.push(`Invalid Soil Type: '${soilTypeRaw}'. Defaulted to 'Unknown'.`);

    const waterAvailabilities: Claim['waterAvailability'][] = ['High', 'Medium', 'Low', 'Unknown'];
    const waterAvailabilityRaw = String(getCellValue(row, ['water availability', 'Water Availability', 'water']) || '').trim();
    const waterAvailability: Claim['waterAvailability'] = waterAvailabilities.includes(waterAvailabilityRaw as Claim['waterAvailability']) ? (waterAvailabilityRaw as Claim['waterAvailability']) : 'Unknown';
    if (waterAvailability === 'Unknown' && waterAvailabilityRaw) errors.push(`Invalid Water Availability: '${waterAvailabilityRaw}'. Defaulted to 'Unknown'.`);

    const estimatedCropValueRaw = getCellValue(row, ['estimated crop value', 'Estimated Crop Value', 'crop value']);
    let estimatedCropValue = 0;
    if (typeof estimatedCropValueRaw === 'number' && !isNaN(estimatedCropValueRaw)) {
      estimatedCropValue = estimatedCropValueRaw;
    } else {
      estimatedCropValue = Math.floor(Math.random() * 20000) + 5000; // Default if invalid
      if (estimatedCropValueRaw) errors.push(`Invalid Estimated Crop Value: '${estimatedCropValueRaw}'. Defaulted to random value.`);
    }

    const documentName = String(getCellValue(row, ['document name', 'Document Name']) || '').trim() || undefined;

    let geometry: any = null;
    let parsedLat: number | null = null;
    let parsedLon: number | null = null;

    // Priority 1: Check for full GeoJSON geometry string
    const rawGeoJson = getCellValue(row, ['geometry', 'geojson', 'Geometry', 'GeoJSON']);
    if (rawGeoJson) {
      try {
        const parsedGeoJson = JSON.parse(String(rawGeoJson));
        if (parsedGeoJson.type === 'Polygon' && Array.isArray(parsedGeoJson.coordinates)) {
          geometry = parsedGeoJson;
          // Attempt to get a centroid for validation
          const firstCoord = parsedGeoJson.coordinates[0][0]; // [lon, lat]
          if (firstCoord && firstCoord.length === 2) {
            parsedLon = firstCoord[0];
            parsedLat = firstCoord[1];
          }
        } else {
          errors.push("Invalid GeoJSON Polygon structure.");
        }
      } catch (e) {
        errors.push(`Invalid GeoJSON string: ${e.message}.`);
      }
    }

    // Priority 2: If no valid GeoJSON, check for lat/lon coordinates
    if (!geometry) {
      const rawLat = getCellValue(row, ['latitude', 'Lat']);
      const rawLon = getCellValue(row, ['longitude', 'Lon']);
      const rawCoords = getCellValue(row, ['location coordinates', 'Location Coordinates', 'coordinates', 'Coordinates']);

      if (typeof rawLat === 'number' && typeof rawLon === 'number') {
        parsedLat = rawLat;
        parsedLon = rawLon;
      } else if (rawCoords) {
        const parts = String(rawCoords).split(',').map(s => parseFloat(s.trim()));
        if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
          let latCandidate = parts[0];
          let lonCandidate = parts[1];
          // Heuristic check for lat/lon order
          if ((Math.abs(latCandidate) > 90 && Math.abs(lonCandidate) <= 90) ||
              (Math.abs(latCandidate) <= 90 && Math.abs(lonCandidate) > 180)) {
            parsedLat = lonCandidate;
            parsedLon = latCandidate;
          } else {
            parsedLat = latCandidate;
            parsedLon = lonCandidate;
          }
        }
      }

      if (parsedLat === null || parsedLon === null || !isWithinIndiaBounds(parsedLat, parsedLon)) {
        errors.push(`Invalid or out-of-bounds coordinates (${parsedLat}, ${parsedLon}). Generating default geometry.`);
        geometry = createPolygonFromCenter(22.5937, 78.9629, areaInAcres > 0 ? areaInAcres : 1); // Default to central India
      } else {
        geometry = createPolygonFromCenter(parsedLat, parsedLon, areaInAcres > 0 ? areaInAcres : 1);
      }
    }

    const updatedDateSerial = getCellValue(row, ['updated', 'Updated', 'date', 'Date']);
    const createdAt = excelSerialToDate(updatedDateSerial) || new Date();
    
    const claimIdFromExcel = String(getCellValue(row, ['parcel id', 'Parcel ID', 'claim id', 'Claim ID']) || '').trim();
    const finalUserFacingClaimId = generateUniqueUserFacingClaimId(claimIdFromExcel);

    if (errors.length === 0) {
      parsedClaim = {
        id: finalUserFacingClaimId,
        holderName,
        village,
        district,
        state,
        area: parseFloat(areaInAcres.toFixed(2)),
        status,
        documentName,
        soilType,
        waterAvailability,
        estimatedCropValue: parseFloat(estimatedCropValue.toFixed(2)),
        geometry,
        created_at: createdAt, // Add created_at for Supabase upsert
      };
    }

    return { originalRow: row, parsedClaim, errors };
  };

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const selectedFile = e.target.files?.[0];
    if (selectedFile) {
      setFile(selectedFile);
      setIsLoading(true);
      generatedUserFacingIdsInBatch.current.clear(); // Clear for new file
      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const data = new Uint8Array(event.target?.result as ArrayBuffer);
          const workbook = XLSX.read(data, { type: "array" });
          const sheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[sheetName];
          const json = XLSX.utils.sheet_to_json(worksheet);
          
          const processed = json.map(row => processExcelRow(row));
          setProcessedData(processed);
        } catch (error: any) {
          showError(`Failed to parse Excel file: ${error.message}`);
          setFile(null);
          setProcessedData([]);
        } finally {
          setIsLoading(false);
        }
      };
      reader.readAsArrayBuffer(selectedFile);
    }
  };

  const validClaimsToImport = useMemo(() => {
    return processedData.filter(row => row.parsedClaim !== null).map(row => row.parsedClaim);
  }, [processedData]);

  const rowsWithErrors = useMemo(() => {
    return processedData.filter(row => row.errors.length > 0);
  }, [processedData]);

  const handleImport = async () => {
    if (!user?.id) {
      showError("You must be logged in to import claims.");
      return;
    }
    if (validClaimsToImport.length === 0) {
      showError("No valid claims to import.");
      return;
    }
    setIsLoading(true);
    const toastId = showLoading(`Importing ${validClaimsToImport.length} claims... This may take a moment.`);

    try {
      // Add user_id to each claim before upserting
      const claimsWithUserId = validClaimsToImport.map(claim => ({
        ...claim,
        user_id: user.id, // Assign the current user's ID
        claim_id: claim?.id, // Map frontend 'id' to backend 'claim_id'
        holder_name: claim?.holderName,
        document_name: claim?.documentName,
        soil_type: claim?.soilType,
        water_availability: claim?.waterAvailability,
        estimated_crop_value: claim?.estimatedCropValue,
      }));

      // Use upsert to update existing claims or insert new ones based on 'claim_id'
      const { error } = await supabase.from('claims').upsert(claimsWithUserId, { onConflict: 'claim_id', ignoreDuplicates: false });
      if (error) throw error;
      
      dismissToast(toastId);
      showSuccess(`${validClaimsToImport.length} claims imported successfully! ${rowsWithErrors.length > 0 ? `(${rowsWithErrors.length} rows had errors and were skipped.)` : ''}`);
      queryClient.invalidateQueries({ queryKey: ['claims', user.id] }); // Invalidate with user.id
      onOpenChange(false);
      setFile(null);
      setProcessedData([]);
    } catch (error: any) {
      dismissToast(toastId);
      showError(`Import failed: ${error.message}`);
    } finally {
      setIsLoading(false);
    }
  };

  const downloadErrorReport = () => {
    if (rowsWithErrors.length === 0) {
      showInfo("No errors to report.");
      return;
    }

    const errorReportData = rowsWithErrors.map(row => ({
      ...row.originalRow,
      "Import Errors": row.errors.join('; '),
    }));

    const ws = XLSX.utils.json_to_sheet(errorReportData);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "Error Report");
    XLSX.writeFile(wb, "fra_claims_error_report.xlsx");
    showSuccess("Error report downloaded.");
  };

  return (
    <Dialog open={isOpen} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-5xl z-[9999]">
        <DialogHeader>
          <DialogTitle>Import Claims from Excel</DialogTitle>
          <DialogDescription className="text-sm text-muted-foreground mt-2">
            Upload an Excel file with claim data. The system will attempt to parse and validate the data.
            Expected columns (case-insensitive, space-tolerant): "parcel id", "patta holder", "village", "district", "state", "area (ha)", "type of right" (IFR/CR/CFR or Approved/Pending/Rejected), "updated" (Excel serial date or YYYY-MM-DD), "latitude", "longitude", "geometry" (full GeoJSON Polygon string), "soil type", "water availability", "estimated crop value".
          </DialogDescription>
        </DialogHeader>
        <div className="py-4 space-y-6">
          <div className="flex flex-col items-center justify-center w-full p-6 border-2 border-dashed rounded-lg">
            <UploadCloud className="w-12 h-12 text-muted-foreground" />
            <p className="mt-2 text-sm text-muted-foreground">
              {file ? `Selected: ${file.name}` : "Select an .xlsx or .csv file to upload"}
            </p>
            <Input id="excel-upload" type="file" className="mt-4" onChange={handleFileChange} accept=".xlsx, .csv" />
          </div>

          {isLoading && (
            <div className="flex items-center justify-center py-8">
              <Loader2 className="mr-2 h-6 w-6 animate-spin text-primary" />
              <span className="text-muted-foreground">Processing file...</span>
            </div>
          )}

          {!isLoading && processedData.length > 0 && (
            <div>
              <h4 className="font-semibold mb-3">Data Preview ({processedData.length} rows)</h4>
              {rowsWithErrors.length > 0 && (
                <Alert variant="destructive" className="mb-4">
                  <FileWarning className="h-4 w-4" />
                  <AlertTitle>Validation Errors</AlertTitle>
                  <AlertDescription>
                    {rowsWithErrors.length} out of {processedData.length} rows have errors and will not be imported.
                    <Button variant="link" className="h-auto p-0 ml-2 text-destructive-foreground underline" onClick={downloadErrorReport}>
                      Download Error Report
                    </Button>
                  </AlertDescription>
                </Alert>
              )}
              <div className="max-h-64 overflow-y-auto border rounded-lg">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead className="py-2">Status</TableHead>
                      <TableHead className="py-2">Parcel ID</TableHead>
                      <TableHead className="py-2">Holder Name</TableHead>
                      <TableHead className="py-2">Village</TableHead>
                      <TableHead className="py-2">Area (acres)</TableHead>
                      <TableHead className="py-2">Soil Type</TableHead>
                      <TableHead className="py-2">Water Avail.</TableHead>
                      <TableHead className="py-2">Est. Crop Value</TableHead>
                      <TableHead className="py-2">Errors</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {processedData.slice(0, 10).map((row, i) => ( // Show first 10 rows
                      <TableRow key={i} className={row.errors.length > 0 ? "bg-red-50/50 dark:bg-red-900/20" : ""}>
                        <TableCell className="py-2">
                          {row.errors.length === 0 ? (
                            <span className="text-green-600">Valid</span>
                          ) : (
                            <span className="text-red-600">Invalid</span>
                          )}
                        </TableCell>
                        <TableCell className="py-2">{row.parsedClaim?.id || 'N/A'}</TableCell>
                        <TableCell className="py-2">{row.parsedClaim?.holderName || 'N/A'}</TableCell>
                        <TableCell className="py-2">{row.parsedClaim?.village || 'N/A'}</TableCell>
                        <TableCell className="py-2">{row.parsedClaim?.area?.toFixed(2) || 'N/A'}</TableCell>
                        <TableCell className="py-2">{row.parsedClaim?.soilType || 'N/A'}</TableCell>
                        <TableCell className="py-2">{row.parsedClaim?.waterAvailability || 'N/A'}</TableCell>
                        <TableCell className="py-2">₹{row.parsedClaim?.estimatedCropValue?.toLocaleString() || 'N/A'}</TableCell>
                        <TableCell className="py-2 text-red-600 text-xs">{row.errors.join('; ')}</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
              <p className="text-sm text-muted-foreground mt-3">Showing first {Math.min(10, processedData.length)} of {processedData.length} rows.</p>
            </div>
          )}
        </div>
        <DialogFooter>
          <Button variant="outline" onClick={() => onOpenChange(false)}>Cancel</Button>
          <Button onClick={handleImport} disabled={isLoading || validClaimsToImport.length === 0}>
            {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
            Import {validClaimsToImport.length} Valid Claims
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default ExcelImportDialog;